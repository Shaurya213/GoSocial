// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"context"
	"firebase.google.com/go/v4"
	"firebase.google.com/go/v4/messaging"
	"fmt"
	"google.golang.org/api/option"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gosocial/internal/common"
	"gosocial/internal/config"
	"gosocial/internal/dbmysql"
	"gosocial/internal/notif"
	"log"
	"os"
)

// Injectors from wire.go:

// InitializeApplication wires up all dependencies
func InitializeApplication() (*Application, error) {
	config := ProvideConfig()
	db, err := ProvideDatabaseConnection(config)
	if err != nil {
		return nil, err
	}
	notificationRepository := dbmysql.NewNotificationRepository(db)
	deviceRepository := dbmysql.NewDeviceRepository(db)
	app, err := ProvideFirebaseApp(config)
	if err != nil {
		return nil, err
	}
	client, err := ProvideFirebaseMessaging(app)
	if err != nil {
		return nil, err
	}
	emailService := ProvideEmailService(config)
	notificationService := notif.NewNotificationService(config, notificationRepository, deviceRepository, client, emailService)
	notificationHandler := notif.NewNotificationHandler(notificationService, config, client, deviceRepository)
	application := &Application{
		Config:  config,
		DB:      db,
		Handler: notificationHandler,
		Service: notificationService,
	}
	return application, nil
}

// wire.go:

// Application holds all dependencies
type Application struct {
	Config  *config.Config
	DB      *gorm.DB
	Handler *notif.NotificationHandler
	Service *notif.NotificationService
}

// ProvideConfig creates application configuration
func ProvideConfig() *config.Config {
	return &config.Config{
		Server: config.ServerConfig{
			Port:         getEnvOrDefault("SERVER_PORT", "8080"),
			Host:         getEnvOrDefault("SERVER_HOST", "0.0.0.0"),
			ReadTimeout:  30,
			WriteTimeout: 30,
			Environment:  getEnvOrDefault("ENVIRONMENT", "development"),
		},
		Database: config.DatabaseConfig{
			Host:         getEnvOrDefault("DB_HOST", "192.168.63.59"),
			Port:         getEnvOrDefault("DB_PORT", "3306"),
			Username:     getEnvOrDefault("DB_USER", "gosocial_user"),
			Password:     getEnvOrDefault("DB_PASSWORD", "G0Social@123"),
			DatabaseName: getEnvOrDefault("DB_NAME", "gosocial_db"),
			MaxOpenConns: 25,
			MaxIdleConns: 5,
		},
		Firebase: config.FirebaseConfig{
			ProjectID:           getEnvOrDefault("FIREBASE_PROJECT_ID", ""),
			CredentialsFilePath: getEnvOrDefault("FIREBASE_CREDENTIALS_PATH", ""),
			Enabled:             getEnvOrDefault("FIREBASE_ENABLED", "false") == "true",
		},
		Notification: config.NotificationConfig{
			Workers:                5,
			ChannelBufferSize:      1000,
			ScheduledCheckInterval: 1,
			MaxRetries:             3,
			RetryDelay:             5,
			Enabled:                true,
		},
		Email: config.EmailConfig{
			SMTPHost:  getEnvOrDefault("SMTP_HOST", ""),
			SMTPPort:  587,
			Username:  getEnvOrDefault("SMTP_USERNAME", ""),
			Password:  getEnvOrDefault("SMTP_PASSWORD", ""),
			FromEmail: getEnvOrDefault("FROM_EMAIL", ""),
			FromName:  getEnvOrDefault("FROM_NAME", "GoSocial"),
			Enabled:   getEnvOrDefault("EMAIL_ENABLED", "false") == "true",
			UseTLS:    true,
		},
		Logging: config.LoggingConfig{
			Level:      getEnvOrDefault("LOG_LEVEL", "info"),
			Format:     getEnvOrDefault("LOG_FORMAT", "text"),
			OutputPath: getEnvOrDefault("LOG_OUTPUT", "stdout"),
		},
	}
}

// âœ… FIXED: Now receives config as a parameter instead of calling ProvideConfig()
func ProvideDatabaseConnection(cfg *config.Config) (*gorm.DB, error) {

	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		cfg.Database.Username,
		cfg.Database.Password,
		cfg.Database.Host,
		cfg.Database.Port,
		cfg.Database.DatabaseName,
	)
	log.Printf("Attempting to connect to database: %s:%s/%s",
		cfg.Database.Host, cfg.Database.Port, cfg.Database.DatabaseName)

	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}
	dbmysql.SetDB(db)

	if err := db.AutoMigrate(
		&dbmysql.Notification{},
		&dbmysql.Device{},
	); err != nil {
		log.Printf("Migration warning: %v", err)
	}

	return db, nil
}

// ProvideFirebaseApp creates Firebase app instance (can return nil)
func ProvideFirebaseApp(cfg *config.Config) (*firebase.App, error) {
	if !cfg.Firebase.Enabled {
		log.Println("Firebase disabled")
		return nil, nil
	}

	if cfg.Firebase.CredentialsFilePath == "" {
		log.Println("Firebase credentials not provided")
		return nil, nil
	}

	opt := option.WithCredentialsFile(cfg.Firebase.CredentialsFilePath)
	firebaseConfig := &firebase.Config{
		ProjectID: cfg.Firebase.ProjectID,
	}

	app, err := firebase.NewApp(context.Background(), firebaseConfig, opt)
	if err != nil {
		log.Printf("Firebase initialization failed: %v", err)
		return nil, nil
	}

	return app, nil
}

// ProvideFirebaseMessaging creates Firebase messaging client (can return nil)
func ProvideFirebaseMessaging(app *firebase.App) (*messaging.Client, error) {
	if app == nil {
		log.Println("Firebase app not available, FCM disabled")
		return nil, nil
	}

	client, err := app.Messaging(context.Background())
	if err != nil {
		log.Printf("Failed to create FCM client: %v", err)
		return nil, nil
	}

	return client, nil
}

// ProvideEmailService creates email service
func ProvideEmailService(cfg *config.Config) common.EmailService {
	return &MockEmailService{}
}

// MockEmailService implements common.EmailService interface
type MockEmailService struct{}

func (m *MockEmailService) SendEmail(to, subject, body string) error {
	log.Printf("Mock Email - To: %s, Subject: %s", to, subject)
	return nil
}

// Helper function to get environment variables with defaults
func getEnvOrDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
