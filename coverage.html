
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handler: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gosocial/internal/chat/handler/chat_handler.go (54.4%)</option>
				
				<option value="file1">gosocial/internal/chat/handler/mocks/mock_chat_service.go (100.0%)</option>
				
				<option value="file2">gosocial/internal/chat/repository/chat_repository.go (100.0%)</option>
				
				<option value="file3">gosocial/internal/chat/service/chat_service.go (86.7%)</option>
				
				<option value="file4">gosocial/internal/chat/service/mocks/mock_chat_repository.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package handler: this the chat handler
package handler

import (
        "context"
        "fmt"
        "io"
        "log"
        "sync"

        pb "gosocial/api/v1/chat" 

        "gosocial/internal/chat/service"
        "gosocial/internal/dbmysql"

        "google.golang.org/grpc/codes"
        "google.golang.org/protobuf/types/known/timestamppb"
)

type ChatHandler struct {
        pb.UnimplementedChatServiceServer
        chatService service.ChatService
        mu          sync.RWMutex
        streams     map[string][]pb.ChatService_StreamMessagesServer
}

func NewChatHandler(chatService service.ChatService) *ChatHandler <span class="cov4" title="8">{
        return &amp;ChatHandler{
                chatService: chatService,
                streams: make(map[string][]pb.ChatService_StreamMessagesServer),
        }
}</span>

//SendMessages is a method that exists
func (h *ChatHandler) SendMessages(ctx context.Context, req *pb.SendMessageRequest) (*pb.SendMessageResponse, error) <span class="cov4" title="7">{
        domainMsg := &amp;dbmysql.Message{
                ConversationID: req.ConversationId,
                SenderID: req.SenderId,
                Content: req.Content,
        }

        savedMsg, err := h.chatService.SendMessage(ctx, domainMsg)

        if err != nil </span><span class="cov3" title="4">{
                return nil, fmt.Errorf( "failed to send Message %v : internal codes : %v", err, codes.Internal )
        }</span>

        <span class="cov2" title="3">protoMsg := &amp;pb.ChatMessage{
                ConversationId: savedMsg.ConversationID,
                SenderId: savedMsg.SenderID,
                Content: savedMsg.Content,
                SentAt: timestamppb.New(savedMsg.SentAt),
        }

        h.broadcastToStream(savedMsg.ConversationID, protoMsg)

        return &amp;pb.SendMessageResponse{
                Success: true,
                Message: protoMsg,
        }, nil</span>
}

func (h *ChatHandler) GetChatHistory(ctx context.Context, req *pb.GetChatHistoryRequest) (*pb.GetChatHistoryResponse, error) <span class="cov4" title="8">{
        domainMessages, err := h.chatService.GetMessageHistory(ctx, req.ConversationId)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Failed to get chat history : %v, Error codes: %v", err, codes.Internal)
        }</span>

        <span class="cov4" title="7">protoMessages := make([]*pb.ChatMessage, 0, len(domainMessages))

        // âœ… FIX: Safe bounds checking for pagination
        start := int(req.Offset)
        limit := int(req.Limit)

        // Handle negative or invalid values
        if start &lt; 0 </span><span class="cov1" title="1">{
                start = 0
        }</span>
        <span class="cov4" title="7">if limit &lt;= 0 </span><span class="cov2" title="2">{
                return &amp;pb.GetChatHistoryResponse{Messages: []*pb.ChatMessage{}}, nil
        }</span>

        // Check if start is beyond available messages
        <span class="cov3" title="5">if start &gt;= len(domainMessages) </span><span class="cov2" title="2">{
                return &amp;pb.GetChatHistoryResponse{Messages: []*pb.ChatMessage{}}, nil
        }</span>

        <span class="cov2" title="3">end := start + limit
        if end &gt; len(domainMessages) </span><span class="cov1" title="1">{
                end = len(domainMessages)
        }</span>

        // Now safe to slice
        <span class="cov2" title="3">for _, msg := range domainMessages[start:end] </span><span class="cov3" title="5">{
                protoMessage := &amp;pb.ChatMessage{
                        ConversationId: msg.ConversationID,
                        SenderId:       msg.SenderID,
                        Content:        msg.Content,
                        SentAt:         timestamppb.New(msg.SentAt),
                }
                protoMessages = append(protoMessages, protoMessage)
        }</span>

        <span class="cov2" title="3">return &amp;pb.GetChatHistoryResponse{
                Messages: protoMessages,
        }, nil</span>
}


func (h *ChatHandler) StreamMessages(stream pb.ChatService_StreamMessagesServer) error <span class="cov0" title="0">{
        var conversationID string

        go func()</span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        protoMsg, err := stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error reciving Messages: %v", err)
                                break</span>
                        }
                        <span class="cov0" title="0">if conversationID == "" </span><span class="cov0" title="0">{
                                conversationID = protoMsg.ConversationId
                                h.mu.Lock()
                                h.streams[conversationID] = append(h.streams[conversationID], stream)
                                h.mu.Unlock()
                        }</span>

                        <span class="cov0" title="0">domainMsg := &amp;dbmysql.Message{
                                ConversationID: protoMsg.ConversationId,
                                SenderID: protoMsg.SenderId,
                                Content: protoMsg.Content,
                        } 

                        savedMsg, err := h.chatService.SendMessage(stream.Context(), domainMsg)

                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to save Steamed Messages: %v", err)
                                continue</span>
                        }

                        <span class="cov0" title="0">brodcastMsg := &amp;pb.ChatMessage{
                                ConversationId: savedMsg.ConversationID,
                                SenderId: savedMsg.SenderID,
                                Content: savedMsg.Content,
                                SentAt: timestamppb.New(savedMsg.SentAt),
                        }
                        h.broadcastToStream(savedMsg.ConversationID, brodcastMsg)</span>
                }
        }()

        <span class="cov0" title="0">select </span>{
        case &lt;-stream.Context().Done():<span class="cov0" title="0">
                h.removeStream(conversationID, stream)
                return stream.Context().Err()</span>
        }
}

func (h *ChatHandler) broadcastToStream(conversationID string, msg *pb.ChatMessage) <span class="cov10" title="268">{
        h.mu.RLock()
        streams, ok := h.streams[conversationID]
        h.mu.RUnlock()

        if !ok </span><span class="cov10" title="268">{
                return
        }</span>

        <span class="cov0" title="0">for _, stream := range streams </span><span class="cov0" title="0">{
                if err := stream.Send(msg); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to print stream: %v", err)
                        //TODO: Remove failed steams
                }</span>
        }
}

func (h *ChatHandler) removeStream(conversationID string, stream pb.ChatService_StreamMessagesServer) <span class="cov9" title="168">{
        h.mu.Lock()
        defer h.mu.Unlock()

        streams, ok := h.streams[conversationID]
        if !ok </span><span class="cov9" title="168">{
                return
        }</span>
        <span class="cov0" title="0">for i, st := range streams </span><span class="cov0" title="0">{
                if st == stream </span><span class="cov0" title="0">{
                        h.streams[conversationID] = append(streams[:i], streams[i+1:]...)
                        break</span>
                }
        }
}

</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ../service/chat_service.go
//
// Generated by this command:
//
//        mockgen -source=../service/chat_service.go -destination=mocks/mock_chat_service.go
//

// Package mock_service is a generated GoMock package.
package mocks 

import (
        context "context"
        dbmysql "gosocial/internal/dbmysql"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockChatService is a mock of ChatService interface.
type MockChatService struct {
        ctrl     *gomock.Controller
        recorder *MockChatServiceMockRecorder
        isgomock struct{}
}

// MockChatServiceMockRecorder is the mock recorder for MockChatService.
type MockChatServiceMockRecorder struct {
        mock *MockChatService
}

// NewMockChatService creates a new mock instance.
func NewMockChatService(ctrl *gomock.Controller) *MockChatService <span class="cov7" title="8">{
        mock := &amp;MockChatService{ctrl: ctrl}
        mock.recorder = &amp;MockChatServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChatService) EXPECT() *MockChatServiceMockRecorder <span class="cov10" title="15">{
        return m.recorder
}</span>

// GetMessageHistory mocks base method.
func (m *MockChatService) GetMessageHistory(ctx context.Context, conversationID string) ([]*dbmysql.Message, error) <span class="cov7" title="8">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMessageHistory", ctx, conversationID)
        ret0, _ := ret[0].([]*dbmysql.Message)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMessageHistory indicates an expected call of GetMessageHistory.
func (mr *MockChatServiceMockRecorder) GetMessageHistory(ctx, conversationID any) *gomock.Call <span class="cov7" title="8">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMessageHistory", reflect.TypeOf((*MockChatService)(nil).GetMessageHistory), ctx, conversationID)
}</span>

// SendMessage mocks base method.
func (m *MockChatService) SendMessage(ctx context.Context, msg *dbmysql.Message) (*dbmysql.Message, error) <span class="cov7" title="7">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SendMessage", ctx, msg)
        ret0, _ := ret[0].(*dbmysql.Message)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SendMessage indicates an expected call of SendMessage.
func (mr *MockChatServiceMockRecorder) SendMessage(ctx, msg any) *gomock.Call <span class="cov7" title="7">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMessage", reflect.TypeOf((*MockChatService)(nil).SendMessage), ctx, msg)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package repository

import (
        "context"
        "gorm.io/gorm"
        _ "gorm.io/gorm"
        //"gosocial/internal/chat/models"
        "gosocial/internal/dbmysql"
)

type ChatRepository interface {
        Save(ctx context.Context, msg *dbmysql.Message) error
        FetchHistory(ctx context.Context, conversationID string) ([]*dbmysql.Message, error)
}

type chatRepo struct {
        db *gorm.DB
}

func NewChatRepository(db *gorm.DB) ChatRepository <span class="cov10" title="4">{
        return &amp;chatRepo{
                db: db,
        }
}</span>

func (r *chatRepo) Save(ctx context.Context, msg *dbmysql.Message) error <span class="cov5" title="2">{
        return r.db.WithContext(ctx).Create(msg).Error
}</span>

func (r *chatRepo) FetchHistory(ctx context.Context, conversationID string) ([]*dbmysql.Message, error) <span class="cov5" title="2">{
        var messages []*dbmysql.Message
        return messages, r.db.Where("conversation_id = ?", conversationID).Find(&amp;messages).Error
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package service

import (
        "context"
        "errors"
        "gosocial/internal/chat/repository"
        "gosocial/internal/dbmysql"
        "time"
)

// ChatService defines 
type ChatService interface {
        SendMessage(ctx context.Context, msg *dbmysql.Message) (*dbmysql.Message, error)
        GetMessageHistory(ctx context.Context, conversationID string) ([]*dbmysql.Message, error)
}

type chatService struct {
        repo repository.ChatRepository
}

// Constructor used in DI/wire
func NewChatService(r repository.ChatRepository) ChatService <span class="cov6" title="2">{
        return &amp;chatService{repo: r}
}</span>

// SendMessage handles message validation and saving
func (s *chatService) SendMessage(ctx context.Context, msg *dbmysql.Message) (*dbmysql.Message, error) <span class="cov10" title="3">{
        // Input Validation
        if msg.ConversationID == "" </span><span class="cov1" title="1">{
                return nil, errors.New("conversation ID cannot be empty")
        }</span>
        <span class="cov6" title="2">if msg.SenderID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("sender ID cannot be empty")
        }</span>
        <span class="cov6" title="2">if msg.Content == "" </span><span class="cov0" title="0">{
                return nil, errors.New("message content cannot be empty")
        }</span>

        // Set server-side timestamp
        <span class="cov6" title="2">msg.SentAt = time.Now().UTC()

        // Save to DB via repository
        err := s.repo.Save(ctx, msg)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return msg, nil</span>
}

// GetMessageHistory returns full message history of a conversation
func (s *chatService) GetMessageHistory(ctx context.Context, conversationID string) ([]*dbmysql.Message, error) <span class="cov6" title="2">{
        if conversationID == "" </span><span class="cov1" title="1">{
                return nil, errors.New("conversation ID is required")
        }</span>

        <span class="cov1" title="1">return s.repo.FetchHistory(ctx, conversationID)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ../repository/chat_repository.go
//
// Generated by this command:
//
//        mockgen -source=../repository/chat_repository.go -destination=mocks/mock_chat_repository.go
//

// Package mock_repository is a generated GoMock package.
package mocks 

import (
        context "context"
        dbmysql "gosocial/internal/dbmysql"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockChatRepository is a mock of ChatRepository interface.
type MockChatRepository struct {
        ctrl     *gomock.Controller
        recorder *MockChatRepositoryMockRecorder
        isgomock struct{}
}

// MockChatRepositoryMockRecorder is the mock recorder for MockChatRepository.
type MockChatRepositoryMockRecorder struct {
        mock *MockChatRepository
}

// NewMockChatRepository creates a new mock instance.
func NewMockChatRepository(ctrl *gomock.Controller) *MockChatRepository <span class="cov6" title="2">{
        mock := &amp;MockChatRepository{ctrl: ctrl}
        mock.recorder = &amp;MockChatRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChatRepository) EXPECT() *MockChatRepositoryMockRecorder <span class="cov10" title="3">{
        return m.recorder
}</span>

// FetchHistory mocks base method.
func (m *MockChatRepository) FetchHistory(ctx context.Context, conversationID string) ([]*dbmysql.Message, error) <span class="cov1" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FetchHistory", ctx, conversationID)
        ret0, _ := ret[0].([]*dbmysql.Message)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FetchHistory indicates an expected call of FetchHistory.
func (mr *MockChatRepositoryMockRecorder) FetchHistory(ctx, conversationID any) *gomock.Call <span class="cov1" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchHistory", reflect.TypeOf((*MockChatRepository)(nil).FetchHistory), ctx, conversationID)
}</span>

// Save mocks base method.
func (m *MockChatRepository) Save(ctx context.Context, msg *dbmysql.Message) error <span class="cov6" title="2">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Save", ctx, msg)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Save indicates an expected call of Save.
func (mr *MockChatRepositoryMockRecorder) Save(ctx, msg any) *gomock.Call <span class="cov6" title="2">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockChatRepository)(nil).Save), ctx, msg)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
